<!DOCTYPE html>
<html>
    <head>
        <title>FCC pyDocs</title>
        <link rel ="stylesheet" href="styles.css"/>
        <link rel ="preconnect" href="https://fonts.gstatic.com">
        <link href="https://fonts.googleapis.com/css2?family=Raleway:ital,wght@0,200;0,400;0,600;1,200;1,300;1,600&family=Source+Code+Pro:ital,wght@0,300;0,400;0,600;1,300;1,400;1,600&display=swap" rel="stylesheet"> 
    </head>
    <body id="top">
        <nav class="StickyNav" id="navbar">
          <header id="header">
            <h1>Python Collections Module</h1>
          </header>
            <ul class='no-bullets'>
                <li class=navlist ><a class="nav-link" href="#What_You_should_know_already">What You should know already</a></li>
                <li class=navlist ><a class="nav-link" href="#Notes_and_Setup">Notes and Setup</a></li>
                <li class=navlist ><a class="nav-link" href="#Collections:_Counter">Collections: Counter</a></li>
                <li class=navlist ><a class="nav-link" href="#Collections:_NamedTuple">Collections: NamedTuple</a></li>
                <li class=navlist ><a class="nav-link" href="#Collections:_OrderedDict">Collections: OrderedDict</a></li>
                <li class=navlist ><a class="nav-link" href="#Collections:_DefaultDict">Collections: DefaultDict</a></li>
                <li class=navlist ><a class="nav-link" href="#Collections:_ChainMap">Collections: ChainMap</a></li>
            </ul>
        </nav>
        <main id="main-doc">
            <section class="main-section" id="What_You_should_know_already">
                <header><h1 class="docs-heading">What You should know already</h1></header>
                <p>Its evident that knowledge of basic Python is required. However here is of <em>external</em> items:</p>
                <ul class="textlist">
                    <li>One the most important things to know is the <code>dict</code> class and hashable objects.<br>A hashable datatype has a <code>__hash__</code> magic method defined. Most Objects from popular libraries are are hashable.</li>
                    <li>The <code>tuple</code> class is also important. For ease of understanding a tuple is an ArrayList that cannot change in size or be edited after creation.</li>
                    <li>Knowledge of the 4 base Python Datatypes is required <code>int</code>, <code>float</code>, <code>str</code>, <code>List</code>.</li>
                    <li>Knowing Objects functionality and inheritance is required.</li>
                    <li>You should have an understanding of how <code>variadic functions</code> work.</li>
                </ul>
            </section>

            <section class="main-section" id="Notes_and_Setup">
                <header><h1 class="docs-heading">Notes and Setup</h1></header>
                    <div class="content">
                        <h3 class="noPaddMar">Notes</h3>
                        Python Collections Module is just an extension to preexisting datatypes in Python. The objects covered here are sole extensions of <code>tuple</code>, <code>dict</code>, <code>List</code>, <code>Set</code>
                        <h3>Setup</h3>
                        A Simple import is all that is required. This module is included in std Python.
                        <p class="code-block">
                            import collections<br>
                            <span class="comment">#or you can import only what you need</span><br>
                            from collections import <em>{obj_name}</em>
                        </p>
                    </div>
                </section>
            
            <section class="main-section" id="Collections:_Counter">
                <header><h1 class="docs-heading">Collections: Counter</h1></header>
                    <div class='content'>
                        <p>The counter class simply counts the number of hashable objects over a Iterable object
                            <br>
                            Instantiation of <code>counter</code> objects: 
                        </p>
                        <p class="code-block">
                            from collections import Counter 
                            <br>
                            <span class="comment"># With sequence of items </span> 
                            <br>
                            print(Counter(['B', 'B', 'A', 'B', 'C', 'A', 'B', 'B', 'A', 'C']))
                            <br>          
                            <span class="comment"># with dictionary </span>     
                            <br>   
                            print(Counter({'A':3, 'B':5, 'C':2}))
                            <br>            
                            <span class="comment"># with keyword arguments  </span>          
                            <br>
                            print(Counter(A=3, B=5, C=2))
                        </p>
                        <h3 class="docs-heading">Output:</h3>
                        <p class="code-block output">
                            Counter({'B': 5, 'A': 3, 'C': 2})<br>
                            Counter({'B': 5, 'A': 3, 'C': 2})<br>
                            Counter({'B': 5, 'A': 3, 'C': 2})<br>
                        </p>
                        <p>It is evident the function of <code>counter</code>. It is used to count distinct values in a Iterable.</p>
                        <h3 class="docs-heading">Update()</h3>
                        <p>Counter contains an important <code>update()</code> method <br> <h4>Demo</h4></p>
                        <p class="code-block">
                            C = Counter(['B', 'B', 'A', 'B', 'C', 'A', 'B', 'B', 'A', 'C'])<br>
                            C.update(['B', 'C', 'C', 'A'])<br>
                            print(C)<br>
                        </p>
                        <h3 class="docs-heading">Output</h3>
                        <p class="code-block output">
                            Counter({'B': 5, 'A': 3, 'C': 2})<br>
                            Counter({'B': 6, 'A': 4, 'C': 4})<br>
                        </p> 
                    </div>
            </section>

            <section class="main-section" id="Collections:_NamedTuple">
                <header><h1 class="docs-heading">Collections: NamedTuple</h1></header>
                    <div class='content'>
                        <p><code>NamedTuple</code> is a Factory Function for Tuples that creates Tuples that have fields with names. This can be used as a basic object Factory or storage unit 
                            since they take up less space than Arrays and Dicts.</p>
                        <Strong>Demo:</Strong>
                        <p class="code-block">
                            from collections import namedtuple<br>
                            <br>
                            <span class="comment"># Declaring namedtuple()</span><br>
                            Store = namedtuple('Store', ['name', 'location', 'revenue'])<br>
                            S = Store("Walmart", "Philadelphia", 0)<br>
                            print(S)<br>
                            <br>
                            <span class="comment"># Converting NamedTuple to dict</span><br>
                            dict_S = S._asdict()<br>
                            print(dict_S)  
                        </p>
                        <p>Explanation: A <code>NamedTuple Factory</code> 'Store' is created with <em>named</em> fields: 'name', 'location', and 'revenue'</p>
                        <strong>Output:</strong>
                        <p class="code-block output">
                            Store(name='Walmart', location='Philadelphia', revenue=0) &nbsp &nbsp<span class="comment">#NamedTuple.__repr__()</span><br>
                            {'name': 'Walmart', 'location': 'Philadelphia', 'revenue': 0} <span class="comment">#._asdict()</span>
                        </p>
                        <strong>Accessing Elements:</strong>
                        You can access elements by index, name or by using <code>getattr()</code>.<br>
                        <strong>Example:</strong>
                        <p class="code-block">
                            print("Index  :", S[0])<br>
                            print("Name   :",S.name)<br>
                            print("getattr:",getattr(S, 'name'))<br>
                        </p>
                        <strong>Output:</strong>
                        <p class="code-block output">
                            Index  : Walmart<br>
                            Name   : Walmart<br>
                            getattr: Walmart<br>
                        </p>
                    </div>
            </section>

            <section class="main-section" id="Collections:_OrderedDict">
                <header><h1 class="docs-heading">Collections: OrderedDict</h1></header>
                <div class="content">
                    <p>OrderedDict is an extension of <code>dict</code> with order auditing methods.</p>
                    <strong>Note: </strong>the dict class does not preserve order. To see why you can imagine a dict that has the backend of an array using indexes as keys and a data attr to create a key: value pair. 
                    Since the hash function used by dict doesn't provide a linear output the <code>OrderedDict</code> is used to hold order.
                    <br>
                    <strong>Demo: </strong>
                    <p class="code-block">
                        from collections import OrderedDict<br>
                        <br>
                        print("Before: ")<br>
                        od = OrderedDict()<br>
                        od['a'] = 1<br>
                        od['b'] = 2<br>
                        od['c'] = 3<br>
                        od['d'] = 4<br>
                        for key, value in od.items():<br>
                        &nbsp &nbsp print(key, value)<br>
                        <br>
                        print("After: "")<br>
                        od['c'] = 5<br>
                        for key, value in od.items():<br>
                        &nbsp &nbsp print(key, value)<br>
                    </p>
                    <strong>Output: </strong>
                    <br>
                    <p class="code-block output half">
                        Before:<br>
                        <br>
                        a 1<br>
                        b 2<br>
                        c 3<br>
                        d 4<br>
                        <br>
                        After:<br>
                        <br>
                        a 1<br>
                        b 2<br>
                        c 5<br>
                        d 4<br>
                    </p>
                    <strong>Note: </strong>deleting elements using <code>.pop([<em>element-name</em>])</code>preserves order as well.
                </div>
            </section>
            <section class="main-section" id="Collections:_DefaultDict">
                <header><h1 class="docs-heading">Collections: DefaultDict</h1></header>
                <div class="content">
                    <p>
                        <code>defaultdict</code> is just another extension of <code>dict</code>. 
                        However it is used to bypass the KeyError when a key value pair retrieval is attempted but the key does not exist. DefaultDict fixes this issue by calling 
                        a supplied <code>default_factory</code> that provides the default value required.
                    </p>
                    <strong>Demo:</strong>
                    <p class="code-block">
                        from collections import defaultdict<br>
                        <br>
                        def default_factory():<br>
                        &nbsp &nbsp    return 0<br>
                        <br>
                        <span class="comment">#normal dict --> Throws KeyError <br></span>
                        d = dict()<br>
                        print(d["Python"]) <span class="comment">#Error --> KeyError: 'Python'<br></span>
                        <br>
                        <span class="comment">
                            #prints 0 since thats the default value for <br>
                        #nonexisting elements<br>
                        </span>
                        d = defaultdict(default_factory)<br>
                        print(d['Python'])<br>
                    </p>
                    <strong>Note: </strong>Using this as the <code>default_factory</code> makes the default value my dynamic as it can be changed during runtime.
                    <p class="code-block">
                        def constant_factory(value):<br>
                        &nbsp &nbsp    return lambda: value<br>
                        <span class="comment">#the lambda function is called and thus can be used for more complex objects</span>
                    </p>
                </div>
            </section>

            <section class="main-section" id="Collections:_ChainMap">
                <header><h1 class="docs-heading">Collections: ChainMap</h1></header>
                <div class="content">
                    <p>ChainMap is many uses, likely why its entry on <em>PyDocs</em> is so long</p>
                    <p>Essentially, <code>ChainMap</code> is the combination of user supplied dictionaries and it uses all its 
                        <em>child</em> dictionaries to create one dictionary object with the data from each of the base dicts </p>
                    <strong>Demo:</strong>
                    <p class="code-block">
                        from collections import ChainMap<br>
                            <br>
                        <span class="comment"># initializing dictionaries <br></span>
                        dic1 = { 'a' : 1, 'b' : 2 } <br>
                        dic2 = { 'b' : 3, 'c' : 4 } <br>
                            <br>
                        <span class="comment"># initializing ChainMap <br></span>
                        chain = ChainMap(dic1, dic2) <br>
                        print(chain)<br>
                        print(chain['a'])<br>
                    </p>
                    <strong>Note:</strong> if there exists a key collision, the key from the FIRST dict is take as the object's key:value pair.<br>
                    <strong>Output:</strong>
                    <p class="code-block output">
                        ChainMap({'a': 1, 'b': 2}, {'b': 3, 'c': 4})<br>
                        1<br>
                    </p>
                    <strong>Note:</strong>There exist 2 ChainMap default iterables: 
                        <code>chain.keys()</code>
                        and
                        <code>chain.values()</code>.<br><br>
                    <h3 class="docs-heading">.new_child(dict_obj)</h3>
                    This method adds the supplied dict to the chain.
                    <h2 class="docs-heading">A Useful ChainMap Behavior</h2>
                    <p class='code-block'>
                        from collections import ChainMap<br>
                        <br>
                        a = {'x': 2, 'y':4,}<br>
                        b = {'u': 8, 'v':16,}<br>
                        <br>
                        chain = ChainMap(a, b)<br>
                        print(chain) <span class="comment">#initial values, no key collisions</span><br>
                        <br>
                        chain['u'] = 1_048_576<br>
                        print(chain) <span class="comment">#u is altered; expected behavior</span><br>
                        <br>
                        del chain['u'] <span class="comment">#delete key 'u'</span><br>
                        print(chain)
                    </p>
                    <strong>Output: </strong>
                    <p class="code-block output">
                        ChainMap({'x': 2, 'y': 4}, {'u': 8, 'v': 16})<br>
                        ChainMap({'x': 2, 'y': 4, 'u': 1048576}, {'u': 8, 'v': 16})<br>
                        ChainMap({'x': 2, 'y': 4}, {'u': 8, 'v': 16})
                    </p>
                    <strong>Explanation: </strong>This paradigm puts new values in the first dict, meaning since it appears first it will hold the value of that key (in this case 'u'). This means that the secondary dicts can be used a default values<code>(default_factory)</code> if a value is deleted or removed 
                </div>
            </section>
        </main>
        <p class='topLink'><a href="#top">TOP</a></p>
    </body>
</html>